local AutoCollector = {}
AutoCollector.__index = AutoCollector

local ByteNetReliable = game:GetService("ReplicatedStorage"):WaitForChild("ByteNetReliable")
-- Note: buffer.fromstring is not available in Lua 5.1, you'll need to handle this differently
local harvestBuffer = buffer.fromstring("\1\1\0\1")
--local harvestBuffer = "\1\1\0\1"  -- Direct string representation

function AutoCollector:new(config)
    local instance = {
        isRunning = false,
        thread = nil,
        config = config or {},
        eventPausedNotified = false
    }
    setmetatable(instance, AutoCollector)
    return instance
end

function AutoCollector:collectTargets()
    while self.isRunning do
        -- Handle event pausing
        if self:handleEventPause() then
            -- Using if/else instead of goto (goto not available in Lua 5.1)
        else
            if not self.isRunning then break end

            -- Get collection queue based on collection type
            local collectionQueue = self:buildCollectionQueue()
            
            if #collectionQueue == 0 then
                if self.config.onEmptyQueue then
                    self.config.onEmptyQueue()
                end
                -- task.wait is not available in Lua 5.1, using wait instead
                wait(2)
            else
                -- Process the queue
                self:processQueue(collectionQueue)
            end
        end

        -- task.wait is not available in Lua 5.1, using wait instead
        wait()
    end
    
    self.thread = nil
end

-- Handle event pausing logic
function AutoCollector:handleEventPause()
    if checkEventStatus() then
        if not self.eventPausedNotified then
            warn("Paused: A selected event is active. Waiting...")
            self.eventPausedNotified = true
        end
        
        while checkEventStatus() and self.isRunning do
            wait(1)
        end
        
        if self.isRunning then
            print("Resuming auto collection - event ended")
            self.eventPausedNotified = false
        end
        return true
    end
    return false
end

-- Build collection queue based on collection type
function AutoCollector:buildCollectionQueue()
    local collectionQueue = {}
    local _, _, Plants_Physical, _ = functions.GetPlayerFarm(localPlayer.Name)
    
    -- Using numeric for loop instead of ipairs for better Lua 5.1 compatibility
    local children = Plants_Physical:GetChildren()
    for i = 1, #children do
        local plant = children[i]
        if not self.isRunning then break end
        
        if plant:IsA("Model") then
            self:processPlant(plant, collectionQueue)
        end
    end
    
    return collectionQueue
end

-- Process individual plant based on collection type
function AutoCollector:processPlant(plant, collectionQueue)
    local fruitsFolder = plant:FindFirstChild("Fruits")
    
    if fruitsFolder then
        -- Process fruits in the plant
        local fruits = fruitsFolder:GetChildren()
        for i = 1, #fruits do
            local fruit = fruits[i]
            if not self.isRunning then break end
            
            if self:shouldCollectTarget(fruit, plant) then
                table.insert(collectionQueue, fruit)
            end
        end
    elseif self:shouldCollectTarget(plant, plant) then
        table.insert(collectionQueue, plant)
    end
end

function AutoCollector:shouldCollectTarget(target, plant)
    return not target:GetAttribute("Favorited")
end

-- Process the collection queue
function AutoCollector:processQueue(collectionQueue)
    for i = 1, #collectionQueue do
        local target = collectionQueue[i]
        if not self.isRunning or checkEventStatus() then break end
        
        pcall(function()
            ByteNetReliable:FireServer(harvestBuffer, {target})
        end)
        
        wait(AutoFarmSpeedGlobal)
    end
end

-- Start the auto-collector
function AutoCollector:start()
    if self.isRunning then return end
    
    self.isRunning = true
    self.eventPausedNotified = false
    
    if self.config.onStart then
        self.config.onStart()
    end
    
    if not self.thread then
        -- task.spawn is not available in Lua 5.1, using coroutine instead
        self.thread = coroutine.create(function()
            self:collectTargets()
        end)
        coroutine.resume(self.thread)
    end
end

-- Stop the auto-collector
function AutoCollector:stop()
    self.isRunning = false
    
    if self.config.onStop then
        self.config.onStop()
    end
end

-- Check if collector is running
function AutoCollector:isActive()
    return self.isRunning
end

-- Specific implementation for Selected Fruits Collection
local SelectedFruitCollector = setmetatable({}, {__index = AutoCollector})

function SelectedFruitCollector:new(fruitDropdown, ignoreMutation)
    local instance = AutoCollector:new({
        onStart = function()
            print("Auto Farm Enabled")
        end,
        onStop = function()
            print("Auto Farm Disabled")
        end,
        onEmptyQueue = function()
            warn("No fruits selected")
        end
    })
    
    instance.fruitDropdown = fruitDropdown
    instance.ignoreMutation = ignoreMutation
    setmetatable(instance, {__index = SelectedFruitCollector})
    return instance
end

function SelectedFruitCollector:shouldCollectTarget(target, plant)
    local targetFruits = functions.parseTargetFruits(self.fruitDropdown)
    if #targetFruits == 0 then return false end
    
    local plantName = plant.Name:lower()
    local isTarget = false
    
    -- table.find is not available in Lua 5.1, using manual search
    for i = 1, #targetFruits do
        if targetFruits[i] == plantName then
            isTarget = true
            break
        end
    end
    
    if not isTarget then return false end
    
    local hasMutation = functions.hasAnyMutation(target, self.ignoreMutation)
    local isFavorited = target:GetAttribute("Favorited")
    
    return not hasMutation and not isFavorited
end

-- Specific implementation for Non-Mutated Collection
local NonMutatedCollector = setmetatable({}, {__index = AutoCollector})

function NonMutatedCollector:new()
    local instance = AutoCollector:new({
        onStart = function()
            print("Auto-collecting non-mutated fruits now")
        end,
        onStop = function()
            print("Auto collection disabled.")
        end
    })
    
    setmetatable(instance, {__index = NonMutatedCollector})
    return instance
end

function NonMutatedCollector:shouldCollectTarget(target, plant)
    local hasMutation = functions.hasAnyMutation(target, functions.sortedMutations)
    local isFavorited = target:GetAttribute("Favorited")
    
    return not hasMutation and not isFavorited
end

-- Return the module
return {
    AutoCollector = AutoCollector,
    SelectedFruitCollector = SelectedFruitCollector,
    NonMutatedCollector = NonMutatedCollector
}
