local otherfunctions = {}

--======== [Event Status Check Function] ======--
otherfunctions.checkEventStatus = function(eventList, ifEventActiveDoNotCollect)
    local f = false
    if eventList.Visible then
        for _, v in ipairs(eventList:FindFirstChild("List"):GetChildren()) do
            if v:IsA("Frame") and v.Visible and ifEventActiveDoNotCollect[v.Name] then
                f = true
                break
            end
        end
    end
    isEventActive = f
    return f
end

--======== [Refresh Fruits List Function] ======--
otherfunctions.refreshFruitsList = function(dropdown, player, functions)
    print("DEBUG :: dropdown", dropdown)
    print("DEBUG :: player", player)
    print("DEBUG :: functions", functions)

    local a, b, Plants_Physical, d = functions.GetPlayerFarm(player)
    print("DEBUG :: Plants_Physical", Plants_Physical)

    if not Plants_Physical then
        warn("Plants_Physical folder not found")
        return
    end

    if not dropdown then
        warn("Dropdown is nil!")
        return
    end

    local uniqueFruits = {}
    for _, plant in ipairs(Plants_Physical:GetChildren()) do
        if plant:IsA("Model") then
            local name = plant.Name
            if not table.find(uniqueFruits, name) then
                table.insert(uniqueFruits, name)
            end
        end
    end

    table.sort(uniqueFruits)
    print("DEBUG :: Refreshing dropdown with:", uniqueFruits)
    dropdown:Refresh(uniqueFruits)
end


--======== [Filter: Selected Fruits] ======--
otherfunctions.selectedFruits = function(targetFruits, ignoreMutation, functions)
    return function(plant, fruitsFolder)
        local targets = {}
        local plantName = plant.Name:lower()
        local isTarget = table.find(targetFruits, plantName)
        if isTarget then
            if fruitsFolder then
                for _, fruit in ipairs(fruitsFolder:GetChildren()) do
                    if not functions.hasAnyMutation(fruit, ignoreMutation) and not fruit:GetAttribute("Favorited") then
                        table.insert(targets, fruit)
                    end
                end
            elseif not functions.hasAnyMutation(plant, ignoreMutation) and not plant:GetAttribute("Favorited") then
                table.insert(targets, plant)
            end
        end
        return targets
    end
end

--======== [Filter: Non-Mutated Fruits] ======--
otherfunctions.nonMutated = function(ignoreMutation, functions)
    return function(plant, fruitsFolder)
        local targets = {}
        if fruitsFolder then
            for _, fruit in ipairs(fruitsFolder:GetChildren()) do
                if not functions.hasAnyMutation(fruit, functions.sortedMutations)
                   and not fruit:GetAttribute("Favorited") then
                    table.insert(targets, fruit)
                end
            end
        elseif not functions.hasAnyMutation(plant, functions.sortedMutations)
               and not plant:GetAttribute("Favorited") then
            table.insert(targets, plant)
        end
        return targets
    end
end

--======== [Filter: Special Mutations] ======--
otherfunctions.specialMutations = function(enabledMutations, ignoreMutation, functions)
    return function(plant, fruitsFolder)
        local targets = {}
        local added = false
        if fruitsFolder then
            for _, fruit in ipairs(fruitsFolder:GetChildren()) do
                if fruit:IsA("Model")
                   and functions.hasAnyMutation(fruit, enabledMutations)
                   and not fruit:GetAttribute("Favorited")
                   and not functions.hasAnyMutation(fruit, ignoreMutation) then
                    table.insert(targets, fruit)
                    added = true
                    break
                end
            end
        end
        if not added and functions.hasAnyMutation(plant, enabledMutations)
           and not plant:GetAttribute("Favorited")
           and not functions.hasAnyMutation(plant, ignoreMutation) then
            table.insert(targets, plant)
        end
        return targets
    end
end

--======== [Collection Loop] ======--
otherfunctions.runCollectionLoop = function(config, cores, ByteNetReliable)
    local eventPausedNotified = false
    while config.isRunning() do
        if config.checkEventStatus and config.checkEventStatus() then
            if not eventPausedNotified then
                cores.notify("Paused: A selected event is active. Waiting...", 3, "triangle-alert")
                eventPausedNotified = true
            end
            while config.checkEventStatus() and config.isRunning() do
                task.wait(1)
            end
            if config.isRunning() then
                cores.notify("Resuming " .. config.resumeMessage .. " - event ended", 2, "check")
                eventPausedNotified = false
            end
        end

        if not config.isRunning() then break end
        local targets = otherfunctions.getCollectionTargets(config)
        if #targets == 0 then
            if config.emptyMessage then
                cores.notify(config.emptyMessage, 3, "check")
            end
            task.wait(2)
        else
            otherfunctions.processTargets(targets, config, cores, ByteNetReliable)
        end
        task.wait()
    end
    if config.threadCleanup then config.threadCleanup() end
end

--======== [Target Scanner] ======--
otherfunctions.getCollectionTargets = function(config)
    local targets = {}
    local success, Plants_Physical = pcall(function()
        local _, _, plants, _ = functions.GetPlayerFarm(localPlayer.Name)
        return plants
    end)
    if not success or not Plants_Physical then return targets end
    for _, plant in ipairs(Plants_Physical:GetChildren()) do
        if not config.isRunning() then break end
        if plant:IsA("Model") then
            local fruitsFolder = plant:FindFirstChild("Fruits")
            local plantTargets = config.filterFunction(plant, fruitsFolder)
            for _, target in ipairs(plantTargets) do
                table.insert(targets, target)
            end
        end
    end
    return targets
end

--======== [Target Processor] ======--
otherfunctions.processTargets = function(targets, config, cores, ByteNetReliable)
    for _, target in ipairs(targets) do
        if not config.isRunning() or (config.checkEventStatus and config.checkEventStatus()) then break end
        local success = pcall(function()
            ByteNetReliable:FireServer(harvestBuffer, {target})
            cores.notify("Collected " .. target.Name, 1, "check")
        end)
        if not success and config.onError then
            config.onError(target)
        end
        task.wait(config.speed or AutoFarmSpeedGlobal)
    end
end

--======== [Collection Task Factory] ======--
otherfunctions.createCollectionTask = function(taskType, params, functions)
    local config = {
        speed = params.speed or AutoFarmSpeedGlobal,
        checkEventStatus = params.checkEventStatus,
        onError = params.onError
    }

    if taskType == "selectedFruits" then
        config.filterFunction = otherfunctions.selectedFruits(params.targetFruits, params.ignoreMutation, functions)
        config.isRunning = params.isRunning or function() return autoFarmRunning end
        config.resumeMessage = "selected fruit collection"
        config.emptyMessage = "No fruits selected"
        config.threadCleanup = function() collectFruitThread = nil end

    elseif taskType == "nonMutated" then
        config.filterFunction = otherfunctions.nonMutated(params.ignoreMutation, functions)
        config.isRunning = params.isRunning or function() return runningCollectNoneMutated end
        config.resumeMessage = "auto collection"
        config.threadCleanup = function() collectNoneThread = nil end

    elseif taskType == "specialMutations" then
        config.filterFunction = otherfunctions.specialMutations(params.enabledMutations, params.ignoreMutation, functions)
        config.isRunning = params.isRunning or function() return shouldCollect() end
        config.resumeMessage = "special mutation collection"
        config.checkEventStatus = nil

    else
        error("Unknown task type: " .. tostring(taskType))
    end

    return config
end

--======== [Collection Start Wrapper] ======--
otherfunctions.startCollection = function(taskType, params, functions, cores, ByteNetReliable)
    local config = otherfunctions.createCollectionTask(taskType, params, functions)
    if params.async then
        task.spawn(function()
            otherfunctions.runCollectionLoop(config, cores, ByteNetReliable)
        end)
    else
        otherfunctions.runCollectionLoop(config, cores, ByteNetReliable)
    end
end

return otherfunctions
